# Лабораторная работа №1
## **Цель:** Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных. Научиться создавать библиотеки.

## **Задача**: Разработать библиотеку для работы с деревом Фенвика с функциями:
- Поиск суммы чисел на отрезке массива.
- Обновление числа в массиве.


## **Список понятий**:
Дерево Фе́нвика (англ. Binary indexed tree) — структура данных, требующая O(n) памяти и позволяющая эффективно (за O(logn)) выполнять следующие операции:
- изменять значение любого элемента в массиве
- выполнять некоторую ассоциативную, коммутативную, обратимую операцию на 
  отрезке [i,j]

## **Алгоритм**:
Библиотека использует класс для реализации дерева Фенвика со следующими методами:
- Конструктор, который берёт массив и преобразует его в массив Фенвика.
- Метод **getSum** для вычисления суммы от i-го до j-го элемента массива, используя массив Фенвика.
- Метод **updateFenwickTree** для обновления значения определённого элемента изначального массива и обновления соответствующих элементов массива Фенвика.
- Метод **printarr** для вывода массивов на экран.

Также для удобства я сделал функцию **test** в библиотеке, для тестирования различных массивов.

В классе **fenwickTree** объявляю 2 вектора, второй(**origArray**) получает элементы массива, который поступает на вход(**SourceArray**). Далее реализуется алгоритм заполнения первого вектора(**FenwickTree**), массива Фенвика. Заполнение происходит путём вычисления сумм элементов исходного массива и записи их в соответствующие элементы массива Фенвика. То, от какого элемента исходного массива необходимо считать сумму всех элементов до текущего элемента исходного массива рассчитывается по формуле **i & (i + 1)**(как написано в комментарии мы находим нижнюю границу суммы по верхней границе суммы, а верхняя граница суммы - это текущий элемент, перебираемый циклом **for**). Далее мы находим сумму этого отрезка в исходном массиве(цикл **while**).
```
	fenwickTree(vector<int> SourceArray) {
		origArray.assign(SourceArray.begin(), SourceArray.end());
		for (int i = 0, k = 0, sum = 0; i < origArray.size(); i++, sum = 0)
		{
			k = i & (i + 1);				// k используется как нижняя граница для нахождения суммы, i как верхняя

			while (k <= i)
			{
				sum += origArray[k];
				k++;
			}
			
			FenwickTree.push_back(sum);
		}
		cout << "Original array: ";
		printarr(origArray);
		cout << "\nFenwick Tree: ";
		printarr(FenwickTree);
	}
```
На данных иллюстрациях показана визуализация массива Фенвика(3 график, слева направо) и пример выполнения операции сумма отрезков, её суть и заполнения массива Фенвика.

![image1](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_1.png)

![image2](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_2.png)

Для вычисления суммы на отрезке можно воспользоваться формулой **sum[k..l] = sum[0..k] - sum[0..l-1]**. Отрезок **sum[0..k]** мы находим в первом цикле. Для этого мы разбиваем отрезок [0..k] на элементы массива Фенвика которые в сумме будут равны значению этого отрезка. Нужные номера элементов массива Фенвика мы находим подставляя число k в формулу: **(k & (k + 1)) - 1** Аналогично находим отрезок [0..l-1].
```
int getSum(int UpperBound, int LowerBound)
	{
		int SumOfRange = 0;
		LowerBound -= 1;

		for (int i = 0; UpperBound != -1; i++)
		{
			SumOfRange += FenwickTree[UpperBound];
			UpperBound = (UpperBound & (UpperBound + 1)) - 1;
		}

		for (int i = 0; LowerBound != -1; i++)
		{
			SumOfRange -= FenwickTree[LowerBound];
			LowerBound = (LowerBound & (LowerBound + 1)) - 1;
		}

		cout << '\n';
		return SumOfRange;
	}
```
Если мы хотим изменить какое-то значение в исходном массиве, то для того, чтобы подсчитать в дальнейшем сумму на любом отрезке нового массива, нам необходимо обновить элементы массива Фенвика, которые связаны с нужным нам элементом исходного массива. Функция на вход получает номер ячейки для изменения и её новое значение. Переменная **diff** отвечает за разницу между прошлым и новым значением обновлённого элемента массива. Для начала мы обновляем значение ячейки в исходном массиве. Также мы добавляем значение **diff** к элементу массива Фенвика с таким же номером(**numOfCell**). Далее подставляя в формулу значение **numOfCell**, находим следующий элемент массива фенвика, который необходимо обновить, т.е. добавить значение **diff**. Повторяем это действие до тех пор пока не выйдем за границы массива Фенвика(цикл **while**)
```
void updateFenwickTree(int numOfCell, int newValue)	//номер ячейки для обновления
	{
		int diff = newValue - origArray[numOfCell];
		origArray[numOfCell] = newValue;
		while (numOfCell <= FenwickTree.size())
		{
			FenwickTree[numOfCell] += diff;
			numOfCell = numOfCell | (numOfCell + 1);
		}
		cout << "Updated original array: ";
		printarr(origArray);
		cout << "\nUpdated Fenwick Tree: ";
		printarr(FenwickTree);
		cout << '\n';
	}
```

На данной иллюстрации показан пример выполнения операции обновления значения и её суть.

![image3](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_3.png)

Также дополнительно была создана функция в классе для вывода массивов на экран: **printarr**.
```
void printarr(vector<int> vector)
	{
		for (int i = 0; i < vector.size(); i++)
		{
			cout << vector[i] << " ";
		}
	}
```

## **Тесты**:
***Предисловие к тестам:*** При написании кода к заданию лучшим способом изобразить работу дерева Фенвика я нашёл цикл **switch** в **while**, так как суть дерева Фенвика в операциях нахождения суммы на промежутке и обновления значений массива Фенвика для будующих операций с этим массивом(например операций нахождения суммы на промежутке). Поэтому один тест выполняется циклично с любым исходным массивом чисел. Я назову это далее как один единственный тест, но в целом я выполню достаточно операций для демонстрации работы библиотеки, что можно расценивать как приемлимое количество тестов.
```
int key = 0;
	while (key == 0)
	{
		int switcher = 0;
		cout << "\nChoose operation:\n- 1 for get sum in range [k..l]\n- 2 for update element\n- something else for end\n";
		cin >> switcher;

		int upperBound = 0, lowerBound = 0;
		int numOfCell = 0, value = 0;

		switch (switcher)
		{
		case 1:
			cout << "Input 1)lower bound and 2)upper bound for your range\n";
			cin >> lowerBound >> upperBound;
			cout << "Sum in range [" << lowerBound << ".." << upperBound << "] : " << test.getSum(upperBound, lowerBound);
			cout << '\n';
			break;
		case 2:

			cout << "\nInput 1)number of cell you wanna change and its 2)value\n";
			cin >> numOfCell >> value;
			test.updateFenwickTree(numOfCell, value);
			break;
		default:
			return 0;
		}
```
### **Сам тест**
Для наглядности я использую такой массив чисел, но в приципе можно использовать массив любого другого размера и значений чисел.
```
int main()
{
	vector<int> array1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };

	test(array1);
}
```
Сначала мы видим начальные данные и возможные операции. Возможные операции будут предлагаться к выполнению после любой выполненной операций из предложенных.

![image4](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_4.png)

Далее выбираем операцию сумму на отрезке, в пример берём отрезок **[3..5]**. Можно сравнить получившийся результат(посчитав вручную).

![image5](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_5.png)

Затем выбираем операцию обновления значения, в качестве примера берём элемент номер **4**(подсчёт ведётся с нулевого элемента), обновляемое значение равно **10**. Видим получившийся результат на обновлённых массивах(опять же можем сравнить с изначальными массивами на предыдущей иллюстрации). Далее для проверки правильности обновления массива и подсчёта суммы на отрезке под влиянием изменений, выполняем операцию суммы на отрезке **[3..5]**(как и в педыдущий раз). Всё работает корректно.

![image6](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_6.png)

На следующей иллюстрации видно 2 "теста", показывающие, что мы также можем обновлять любые элементы любыми значениями.

![image7](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_7.png)

Подводя итог выполняем последние 2 "теста", показывающие, что мы также можем считать суммы элементов массива на любых отрезках.

![image8](https://github.com/iit-22170x/RPIIS/blob/%D0%9A%D1%80%D1%8E%D0%BA_%D0%92_%D0%92/sem2/pictures/lab1_8.png)

## Вывод:
Я научился писать библиотеки на языке С++, создал библиотеку для работы с деревом Фенвика, с помощью которой можно вычислять сумму чисел на отрезке массива и обновлять значения за логарифмическую сложность.

---

А также научился работать с двоичным видом числа, изучил логическое и/или.

## Источники:
[Понятие дерева Фенвика](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%A4%D0%B5%D0%BD%D0%B2%D0%B8%D0%BA%D0%B0)

[Теория](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)

[Объяснение работы дерева Фенвика(видео, откуда взяты вырезки)](https://www.youtube.com/watch?v=muW1tOyqUZ4&ab_channel=%D0%9E%D0%BB%D0%B5%D0%B3%D0%A1%D1%82%D0%B8%D0%BF%D0%BB%D0%B8%D0%BD)